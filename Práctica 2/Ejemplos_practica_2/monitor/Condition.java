/* Copyright 2007--2009 Theodore S. Norvell. All rights reserved.   Updated 2009 Mar 13 Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,      this list of conditions and the following disclaimer.   2. Redistributions in binary form must reproduce the above copyright notice,      this list of conditions and the following disclaimer in the documentation      and/or other materials provided with the distribution.   3. Neither the source nor binary form shall be included in any product used by      or intended for use by any military organization. THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITYAND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THEODORENORVELL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, ORCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTEGOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USEOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.*/package monitor;/** A condition queue. * <p> * Uses the signal and wait discipline (SW) or signal and leave (SL). * <p> * Each Condition object is associated with a single {@link Assertion} object * and a single <code>AbstractMonitor</code> object. To construct * a condition use the <code>makeCondition</code> methods from * <code>{@link AbstractMonitor}</code> or {@link Monitor} * <p> * Threads can wait for the assertion represented by the Assertion * object to become true by calling method <code>await()</code>. * Threads can indicate that the assertion has become true by calling * either method <code>signal()</code> (SW) or <code>signalAndLeave()</code> * (SL). All these methods check the assertion and the monitor's invariant * as appropriate. * <p>Threads which wait on a Condition may supply a priority. * In the absence of priority, waiting is fair -- in fact first-in last-out (FIFO). * <p> * Each of the <code>await()</code>, <code>signal()</code>, and * <code>signalAndLeave()</code> methods have corresponding conditional * versions, which first check the assertion before awaiting or signalling. * These are: <code>conditionalAwait()</code>, <code>conditionalSignal()</code>, and * <code>conditionalSignalAndLeave()</code>. * <p> * Conditions also support a {@link #count} accessor to determine the number of threads * waiting on the condition. * <p> * Condition objects are intended to be used only by the thread which * occupies the monitor which created them.  *  * @author Theodore S. Norvell * @version 2.0 * @see AbstractMonitor * @see Monitor * @see Assertion*/public class Condition{    final private AbstractMonitor homeMonitor ;    final private Assertion assertion ;    final private Semaphore queue ;    volatile private int count ;    final private String name ;    Condition( String _name, AbstractMonitor _homeMonitor, Assertion _assertion ) {    	name = _name ;        homeMonitor = _homeMonitor ;        assertion = _assertion ;        queue = new Semaphore(0) ;        count = 0 ; }        public String getName() {    	return name ; }    /** Just like await, but with a priority. Threads awaiting with a lesser priority value are     * re-admitted to the monitor in preference to threads awaiting with a greater priority value.     * When priority values are the same, the order is FIFO.     * @param priority Lower value means more urgent.     * @throws AssertionError if the current thread is not the occupant.     * @throws AssertionError if the invariant is not true to start     * @throws AssertionError if the assertion is not true on return     * @see #await()     */    public void await(int priority) {    	homeMonitor.notifyCallAwait(this) ;        Assertion.check( homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant") ;        count += 1 ;        Assertion.check( homeMonitor.invariant(),"Invariant of monitor "+homeMonitor.getName() ) ;        homeMonitor.occupant = null ;        homeMonitor.entrance.release() ;        queue.acquire(priority) ;        count -= 1 ;        homeMonitor.occupant = Thread.currentThread() ;        // It's not clear that the following check is needed anymore,        // as there is now a check made on the signal.        assertion.check() ;    	homeMonitor.notifyReturnFromAwait( this ) ;    }        /** Wait until a condition is signalled.     * The thread waits outside the monitor until the     * condition is signalled.     * <p> Precondition: Increasing the count by 1     *     must make the invariant true.     *     This thread is in the monitor.     * <p> Postcondition: The assertion associated     *     with this condition queue. This thread is in the monitor.     * <p>Note: threads are queued in a FIFO manner unless a priority is used;     * <kbd>cond.await()</kbd> is equivalent to <kbd>cond.await( Integer.MAX_VALUE )</kbd>.     * @throws AssertionError if the current thread is not the occupant.     * @throws AssertionError if the invariant is not true to start     * @throws AssertionError if the assertion is not true on return     */   public void await() {    	await( Integer.MAX_VALUE ) ;    }    /** Wait only if the condition is not already true.      * @throws AssertionError if neither the invariant nor the assertion associated      * with this object is true      * @throws AssertionError if the current thread is not the occupant.      * @throws AssertionError if the assertion is not true on return      * @see #await()     * */    public void conditionalAwait() {    	conditionalAwait( Integer.MAX_VALUE ) ;    }        /** Just like conditionalAwait, but with a priority.      *       * @param priority Lower value means more urgent.      * @throws AssertionError if neither the invariant nor the assertion associated      * with this object is true      * @throws AssertionError if the current thread is not the occupant.      * @throws AssertionError if the assertion is not true on return      * @see #conditionalAwait()      * @see #await( int priority )      *      */    public void conditionalAwait(int priority) {        if( ! assertion.isTrue() ) await(priority) ; }    /** Signal this condition if there is a waiting thread.     * <p>     * Allows one thread that was waiting on the condition to reenter the monitor.     * Consequently the signalling thread waits outside.      * The signalling thread is allowed back into the monitor, once the monitor is     * again unoccupied. Threads which have signalled wait with a higher than normal     * priority and thus are allowed in ahead of other threads that are waiting to     * enter the monitor (e.g., those waiting in {@link AbstractMonitor#enter()}).     * <p>     * If there is no waiting thread, then this is a no-op, but the invariant is still     * checked, as it is a postcondition.     *  <p> Preconditions:     *      <ul><li>If isEmpty(), the monitor's invariant must be true.</li>     *          <li>If not isEmpty(), then decreasing count() by 1 must make     *          the proposition associated with this condition true.</li>     *          <li>This thread is in the monitor.</li>     *      </ul>     *  <p> Postcondition:     *      <ul><li>The monitor's invariant.     *          <li>This thread is in the monitor.     *      </ul>     *           * @throws AssertionError if the current thread is not the occupant.     * @throws AssertionError if there is a waiting thread and the     *         assertion is false (after decreasing the count by 1).     * @throws AssertionError if invariant is false on return.     *             */    public void signal() {    	    	Assertion.check( homeMonitor.occupant == Thread.currentThread(),    					 "Thread is not occupant") ;                if( count > 0 ) {            try{ count -= 1; assertion.check() ; } finally { count += 1 ; }             homeMonitor.notifySignallerLeavesTemporarily( this ) ;        	homeMonitor.notifySignallerAwakesAwaitingThread( this ) ;        	homeMonitor.occupant = null ;        	queue.release() ;        	            homeMonitor.entrance.acquire(0) ; // Priority 0 puts the signaller ahead of others.            homeMonitor.occupant = Thread.currentThread() ;             homeMonitor.notifySignallerReenters( this ) ; }        Assertion.check( homeMonitor.invariant(),"Invariant of monitor "+homeMonitor.getName() ) ;    }    /** Allows one thread which was     *  waiting on the condition to reenter the monitor.     *  This thread (the one calling signalAndLeave) leaves the monitor immediately.     *  <p> Preconditions:     *      <ul><li>If isEmpty(), the monitor's invariant must be true.</li>     *          <li>If not isEmpty(), then decreasing count() by 1 must make     *          the proposition associated with this condition true.</li>     *          <li>This thread is in the monitor.</li>     *      </ul>     *  <p> Postcondition: This thread is not in the monitor.     *           * @throws AssertionError if the current thread is not the occupant.     * @throws AssertionError if there is a waiting thread and the     *         assertion is false (after decreasing the count by 1).     * @throws AssertionError if there is no waiting thread and the invariant is false.     * @see #signal()    */    public void signalAndLeave()  {    	    	Assertion.check( homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant") ;                if( count > 0 ) {            try{ count -= 1; assertion.check() ; } finally { count += 1 ; }             homeMonitor.notifySignallerAwakesAwaitingThread( this ) ;            homeMonitor.occupant = null ;            queue.release() ; }                else {            Assertion.check( homeMonitor.invariant(), "Invariant of monitor "+homeMonitor.getName() ) ;            homeMonitor.occupant = null ;            homeMonitor.entrance.release() ; }        homeMonitor.notifySignallerLeavesMonitor( this ) ;        }    /** Signal if there is a waiting thread, then leave the monitor.     * Allows one thread which was     *  waiting on the condition to reenter the monitor.     *  This thread (the one calling signalAndLeave) leaves the monitor immediately.     *  <p> Preconditions:     *      <ul><li>If isEmpty(), the monitor's invariant must be true.</li>     *          <li>If not isEmpty(), then decreasing count() by 1 must make     *          the proposition associated with this condition true.</li>     *          <li>This thread is in the monitor.</li>     *      </ul>     *  <p> Postcondition: This thread is not in the monitor.     *           * @throws AssertionError if the current thread is not the occupant.     * @throws AssertionError if there is a waiting thread and the     *         assertion is false (after decreasing the count by 1).     * @throws AssertionError there is no waiting thread and the invariant is false.     * @param result A value to return.     * @return The value of the <kbd>result</kbd> parameter.    */    public <T> T signalAndLeave(T result)  {    	signalAndLeave() ;        return result ; }        /** Signal this condition if its assertion is true and there is a waiting thread.     * <p> More precisely the condition is only signalled if     * its assertion would be true after the count is     * decreased by 1 and there is a waiting tread.     * <p>     * In such a case, the signalling thread waits outside.      * The signalling thread is allowed back into the monitor, once the monitor is     * again unoccupied. Threads which have signalled wait with a higher than normal     * priority and thus are allowed in ahead of other threads that are waiting to     * enter the monitor (e.g., those waiting in {@link AbstractMonitor#enter()}).     *      * <p> If the there are no awaiting threads, or the condition's assertion would not be true     * after the count were decreased by one, this method is essentially a no-op, although     * the invariant is still checked in such a case.     *      *  <p> Preconditions:     *      <ul><li>If isEmpty(), the monitor's invariant must be true.</li>     *          <li>This thread is in the monitor.</li>     *      </ul>     *  <p> Postcondition:     *      <ul><li>The monitor's invariant.     *          <li>This thread is in the monitor.     *      </ul>     *           * @throws AssertionError if the current thread is not the occupant.     * @throws AssertionError if invariant is false on return.     * @see #signal()    */    public void conditionalSignal() {    	Assertion.check( homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant") ;        	if( count > 0 ) {    		boolean wouldBeTrue ;    		count -= 1 ; wouldBeTrue = assertion.isTrue() ; count += 1 ;    		if( wouldBeTrue ) {    			homeMonitor.notifySignallerAwakesAwaitingThread( this ) ;    			homeMonitor.notifySignallerLeavesTemporarily( this ) ;    			homeMonitor.occupant = null ;    			queue.release() ;    			    	        homeMonitor.entrance.acquire() ;    			homeMonitor.occupant = Thread.currentThread() ;    			homeMonitor.notifySignallerReenters( this ) ; } }        Assertion.check( homeMonitor.invariant(), "Invariant of monitor "+homeMonitor.getName() ) ;    }    /** Signal this condition if its assertion is true and there is a waiting thread; leave regardless.     * <p> More precisely the condition is only signalled if     * the assertion would be true after the count is     * decreased by 1 and there is a waiting thread.     * <p>This thread (the one calling signalAndLeave) leaves the monitor immediately.     *      *  <p> Preconditions:     *      <ul><li>If isEmpty() or the assertion would     *           be false after decreasing the count by 1,     *           the monitor's invariant must be true.</li>     *          <li>This thread is in the monitor.</li>     *      </ul>     *  <p> Postcondition:     *      <ul><li>This thread is not in the monitor.     *      </ul>     *           * @throws AssertionError if the current thread is not the occupant.     *  @throws AssertionError there is no waiting thread and the invariant is false.     *  @throws AssertionError if there is a waiting thread and the     *         assertion is false (after decreasing the count by 1)     *         and the invariant is false.     * @see #signalAndLeave()     * @see #conditionalSignal()     *     */    public void conditionalSignalAndLeave()  {    	Assertion.check( homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant") ;     	if( count > 0 ) {    		boolean wouldBeTrue ;    		count -= 1 ; wouldBeTrue = assertion.isTrue() ; count += 1 ;    		if( wouldBeTrue ) {    			homeMonitor.notifySignallerAwakesAwaitingThread( this ) ;    			homeMonitor.notifySignallerLeavesMonitor( this ) ;    			homeMonitor.occupant = null ;    			queue.release() ; }    		else {    			homeMonitor.notifySignallerLeavesMonitor( this ) ;    			homeMonitor.leaveWithoutATrace() ; } }    	else {    		homeMonitor.notifySignallerLeavesMonitor( this ) ;    		homeMonitor.leaveWithoutATrace() ; }    }    /** Signal this condition if its assertion is true and there is a waiting thread. Leave regardless.     * More precisely the condition is only signalled if     * the assertion would be true after the count is     * decreased by 1.     * <p>This thread (the one calling signalAndLeave) leaves the monitor immediately.     *      *  <p> Preconditions:     *      <ul><li>If isEmpty() or the assertion would     *           be false after decreasing the count by 1,     *           the monitor's invariant must be true.</li>     *          <li>This thread is in the monitor.</li>     *      </ul>     *  <p> Postcondition:     *      <ul><li>This thread is not in the monitor.     *      </ul>     *           * @throws AssertionError if the current thread is not the occupant.     *  @throws AssertionError there is no waiting thread and the invariant is false.     *  @throws AssertionError if there is a waiting thread and the     *         assertion is false (after decreasing the count by 1)     *         and the invariant is false.     * @param result A value to be returned.     * @return The value of the <kbd>result</kbd> parameter.     * @see #conditionalSignalAndLeave()     *     */    public <T> T conditionalSignalAndLeave(T result)  {    	conditionalSignalAndLeave() ;    	return result ;    }    /** Test if any thread is waiting on this condition.      * @throws AssertionError if the current thread is not the occupant.      * @return count() == 0 .    */    public boolean isEmpty() {    	Assertion.check( homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant") ;    	return count == 0 ; }    /** How many threads are waiting on this condition.      * @throws AssertionError if the current thread is not the occupant.      * @return the number of Threads waiting on this condition.    */    public int count() {    	Assertion.check( homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant") ;    	return count ; }}